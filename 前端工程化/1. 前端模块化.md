# 前端模块化

前端模块化就是将各个功能进行拆分， 并且完成每部变量私有化， 然后提供接口 API 供外部使用。

1. 全局命名冲突

2. 全局命名空间

```js
var _module = {};
```

有是优化问题

闭包解决私有化问题

3. IIFE 创建 闭包

问题无法解决模块之间 的相互依赖问题

增强想的 IIFE 支持模块化

```js
// module.js 文件
(function (global) {
    var a  = 1;
    function api() {
        return {
            code: 0,
            data: {
                a,
                b： 1，
            }
        }
    }
    function handle(data, key) {
        return data.data[key]
    }
    global.__Module_API = {
        api,
        handle,
    }
})(window)


// entry.js 引入 module.js 的文件
(function(global, moduleAPI) {
    function sum(a, b) {
        return a + b;
    }
    global.__Module = {
        api: moduleAPI.api,
        handle: moduleAPI.handle,
        sum,
    }
})(window.window.__Module_API)
```

## CommonJS

Node.js 默认模块化规范，每个文件就是一个模块，有自己的作用域
Node 中 CJS 模块加载采用同步加载方式
通过 require 加载模块，通过 exports 或 module.exports 输出模块

特点：
所有代码都运行在模块作用域，不会污染全局作用域。
模块可以多次加载，第一次加载时会运行模块，模块输出结果会被
缓存，再次加载时，会从缓存结果中直接读取模块输出结果。
模块加载的顺序，按照其在代码中出现的顺序。

模块输出的值是值的拷贝，类似 IIFE 方案中的内部变量。

为啥么第一次引入会执行一遍呢？

CommonJS 实现原理；
<img src="./img/commonjs.png" />

CommonJS 打包

1. 安装 browserify:npm install browserify-g
2. 模块打包命令：browserify module_test/cjs/entry.js-o dist/bundle.js
3. 注意，当存在多个模块时，每个模块都需要单独打包

browserify 打包原理

1. 本质还是通过自执行函数实现模块化
2. 将每个模块编号，存入一个对象，每个模块标记依赖模块
3. 实现了 require 方法，核心是通过 call 方法调用模块，并传入 require、module、exports 方法,通过 module 存储模块信息，通过 exports 存储模块输出信息
