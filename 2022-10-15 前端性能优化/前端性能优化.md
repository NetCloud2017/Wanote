### 前端性能优化

    1.说说对前端性能优化的理解
    2. 说说你项目做过哪些性能优化？
    3. react 如何进行性能优化
    4. 项目实施过程中是如何考虑性能的？
    5. Vue 的性能为啥比React 好？
    6. 为啥 VDOM 比真实的dom 快？
    7. 了解浏览器火焰图

**[性能指标](#index)**

<h3 id="index">1.常用指标</h3>

**FP-first print: 首次绘制时间**

⾸次绘制包括了任何⽤户⾃定义的背景绘制，它是将第⼀个像素点绘制到屏幕的时刻，对于应⽤⻚⾯，⽤户在视觉上⾸次出现不同于跳转之前的内容时间点，或者说是⻚⾯发⽣第⼀次绘制的
时间点。

**FCP - first contented print ：⾸次有内容绘制时间**
指浏览器完成渲染 DOM 中第⼀个内容的时间点，可能是⽂本、图像、SVG 或者其他任何元素，此时⽤户应该在视觉上有直观的感受。

**FMP - first meaningful print：⾸次有意义绘制时间**

指⻚⾯关键元素渲染时间。这个概念并没有标准化定义，因为关键元素可以由开发者⾃⾏定义——究竟什么是“有意义”的内容，只有开发者或者产品经理⾃⼰了解。

**TTI - Time to Interactive：⽤户可交互时间**

顾名思义，也就是⽤户可以与应⽤进⾏交互的时间。⼀般来讲，我们认为是 domready 的时间，因为我
们通常会在这时候绑定事件操作。如果⻚⾯中涉及交互的脚本没有下载完成，那么当然没有到达所谓的
⽤户可交互时间。那么如何定义 domready 时间呢？

**TTFB - time for first byte：⽹络请求耗时**

TTFB 是发出⻚⾯请求到接收到应答数据第⼀个字节所花费的毫秒数

**DCL：DomContentLoaded**

**L：DOM onload**

**总下载时间**

⻚⾯所有资源加载完成所需要的时间。⼀般可以统计 window.onload 时间，这样可以统计出同步加载的资源全部加载完的耗时。如果⻚⾯中存在较多异步渲染，也可以将异步渲染全部完成的时间作为总下载
时间。

**DOMContentLoaded 与 load 事件的区别**

DOMContentLoaded 指的是⽂档中 DOM 内容加载完毕的时间，也就是说 HTML 结构已经完整。但是我们知道，很多⻚⾯包含图⽚、特殊字体、视频、⾳频等其他资源，这些资源由⽹络请求获取，DOM 内容加载完毕时，由于这些资源往往需要额外的⽹络请求，还没有请求或者渲染完成。⽽当⻚⾯上所有资源加载完成后，load 事件才会被触发。因此，在时间线上，load 事件往往会落后于 DOMContentLoaded 事件。

**关于 DOMContentLoaded 和 domReady ？**

我们简单说⼀下，浏览器是从上到下，从左到右，⼀个个字符串读⼊，⼤致可以认为两个同名的开标签与闭标签就是⼀个 DOM(有的是没有闭签)，这时就忽略掉它的两个标签间的内容。⻚⾯上有许多标
签, 但标签会⽣成同样多的 DOM，因为有的标签下只允许存在特定的⼦标签，⽐如 tr 下⾯⼀定是 td,th,select 下⾯⼀定是 opgroup,option，⽽ option 下⾯，就算你写了<span></span>，它都会忽略掉，option 下⾯只存在⽂本，这就是我们需要⾃定义下拉框的缘故。
我们说过, 这顺序是从上到下, 有的元素很简单,会构建得很快,但标签存在 src, href 属性,它会引⽤外部
资源,这就要区别对待了.⽐如说, script 标签,它⼀定会等 src 指定的脚本⽂件加载下来,然后全部执⾏了⾥⾯的脚本,才会分析下⼀个标签.这种现象叫做堵塞.
堵塞是⼀种⾮常致命的现象,因为浏览器渲染引擎是单线程的,如果头部脚本过多过⼤会导致⽩屏,影响
⽤户体验,因此雅⻁的 20 军规就有⼀条提到 ,将所有 script 标签放到 body 之后.
此外, style 标签与 link 标签,它们在加载样式⽂件时是不会堵塞,但它们⼀旦异步加载好,就⽴即开始渲染已经构建好的元素节点们, 这可能会引起 reflow, 这也影响速度.
另⼀个影响 DOM 树构建的因此是 iframe,它也会加载资源, 虽然不会堵塞 DOM 构建,但它由于是发出 HTTP 请求,⽽ HTTP 请求是有限,它会与⽗标签的其他需要加载外部资源的标签产⽣竞争。我们经常看到⼀些新闻⽹,上⾯会挂许多 iframe ⼴告, 这些⻚⾯⼀开始加载时就很卡,也是这缘故.
此外还有 object 元素, ⽤来加载 flash

```js
<script>document.getElementById();</script>
```

等等，这些东⻄都会影响到 DOM 树的构建过程.因此在这时候,当我们贸贸然,使⽤ getElementById,getElementsByTagName 获取元素,然后操作它们, 就会有很⼤机率碰到 元素为 null 的 异常. 这时, ⽬标元素还可以没有转换为 DOM 节点, 还只是⼀个普通的字符串呢!

很早期, 浏览器提供了⼀个 window.onload ⽅法,但这东⻄是等到所有标签变成 DOM,并且外部资源,图⽚,背景⾳乐什么都加载好才触发, 时间上有点晚.
幸好,浏览器提供了⼀个 document.readyState 属性,当它变成 complete 时,说明这时机到了但这是⼀个属性,不是⼀个事件,需要使⽤不太精确的 setInterval 轮询在标签浏览器, W3C 终于绅⼠地提供了⼀个 DOMContentLoaded 事件把这件事解决了。
