## object 为什么不能替代类上的泛型？

原因一：编译期间 object 无法进行类型安全检查，而泛型在编译期间可以进行类型安全检查

原因二:object 类型数据无法接受非 object 类型的变量，只能接受 object 类型的变量，泛型能轻松做到

原因三：object 类型数据获取属性和方法时无自动提示一种泛型类型被具体化成某种数据类型后，该数据类型的变量获取属性和方法时会有自动提示。

## Object object unknown any 之间的区别

Object 是所有对象的基础， 包括实例化的对象。 他可以被赋值给任何对象，和其他如数字类 Number 、 正则 RegExp 、字符串 String 等的实例。

```js
    let  obj：Object = 123 // 正确
    let  obj1 = Object = {} // 正确
```

object 就只能赋值给对象类型, 如 function 、 [] 和 {} 。

unknown 和 any 都是其他类的顶层类型， any 可以作为其他类型的子类型， unknown 不能，any 在编译期间不会报错， unknown 会； unknown 类型的值只能是 any 和其本身。

## any 为什么不能替代类上的泛型？

原因一：编译期间 any 无法进行类型安全检查，而泛型在编译期间可以进行类型安全检查,

原因二：any 扩大数据类型的属性后没有编译错误导致潜在错误风险，而泛型却有效的避免了此类问题发生;

原因三：any 类型数据获取属性和方法时无自动提示，泛型有自动提示;
