# 类型守卫

首先了解下 常见一个构造函数在 new 的过程中做了那些事。

```js
// 面试题
function People() {
	this.xxx = xxx;
}
// new一个实例对象的底层3步
//1.创建一个object对象
//var obj = new Object();
var obj = {};
console.log("obj", person);
// 2.让新创建的对象的_proto_ 变量指向 Person 原型对象空间
obj._proto_ = Person.prototype;
// 3.借用person构造函数中的为 obj对象变量增加 age属性和 phone 属性
Person.apply(obj, ["12344", 23]);
console.log("obj:", obj);
```

## 为什么要用类型守卫：

类型守卫定义：在语句的块级作用域【if 语句内或条目运算符表达式内】缩小变量的一种类型推断的行为。

类型守卫产生时机：TS 条件语句中遇到下列条件关键字时，会在语句的块级作用域内缩小变量的类型，这种类型推断的行为称作类型守卫（Type Guard)。类型守卫可以帮助我们在块级作用域中获得更为需要的精确变量类型，从而减少不必要的类型断言。

·类型判断：typeof
·属性或者方法或者函数判断：in
·实例判断：instanceof
·字面量相等判断：==，===, !=，!==

```js
//大厂TS类型守卫晋级考核题【综合题】：
// 请编写一个操作对象方法和属性的函数实现以下功能
// 1.当对象字符串属性有空格时就去掉空格后输出，
// 2.当遇到对象方法时就执行，其他数据类型的属性一律直接输出
// 3.只有对象中包含allowoutput属性时，才允许输出。
// 4.函数接收到外部传入的null,undefined，{}时，直接输出不是一个合法的对象
// 考核点：1.考核对类型守卫的熟练运用程度2.静态方法
interface TestInter {
	username: string;
	age: number;
	eat(): viod;
	noallowinput?: 1;
}
let testobj: TestInter = {
	username: "wan g wu",
	age: 23,
	allowinput: 1,
	eat() {
		console.log("eat");
	},
};
function processobjoutput(obj: any) {
	if (obj && JSON.stringify(obj) !== "{}" && "noallowinput" in obj) {
		console.log("属性 或方法存在");
		let value;
		Object.keys(obj).forEach((key) => {
			value = obj[key];
			if (typeof value === "string") {
				// typeof 只能判断 string  /  boolean / number  / function / biginit / symbol / undefined / object / 这八种类型；
				// 类型守卫 typeof  守卫了value 是 string 这个类型， 所以这里的value就有 ,string 对应的方法和属性， 其他类型同理。
				console.log(value.replace(/\s+/g, ""));
			} else if (typeof value === "function") {
				value.call(obj);
			} else {
				console.log(obj[key]);
			}
		});
	} else {
		console.log("不能为空对象");
	}
}
```

## typeof 的局限性

typeof 用来检测一个变量或一个对象的数据类型。

typeof 检测的范围

typeof 检测变量的类型范围包括：“string”|"number"|"bigint"|"boolean"|"symbol"|"undefined”|"object”|"function"等数据类型。

**typeof 的局限性**

typeof 检测变量并不完全准确，例如 typeof null 结果为 object，这其实设计者的一个 bug，但后来一直没有被改过来，于是就此传下来了，但把 null 当成 object 的理由说成是未来可能会拥有一个对象空间，这个理由很牵强【我们检测的是对象变量此刻的类型】，null 本来即是数据类型，也是值。所以 typeof null 直接显示 null 最合适了。

再例如：使用 typeof 来检测一个数组变量，typeof []结果显示的是 object,从 Array 创建的本质上来说确实是 object,正如我们在 2-29-1 中所讲，但开发者期待看到的是 Array，这更符合预期。Array 和我们定义的普通函数一样，具有双重性，当成函数类型时用来创建数组对象，但也是一个构造函数对象，拥有静态成员和 prototype 原型对象属性。【这一点我们在 TS 继承课题已经讲过】

再比如：使用 typeof 来检测一个 Set 变量，Map 变量，结果显示的是依然是 object。

<div style="color: #1fa">为啥都是 typeof 的其他数据都是 object 呢？就是因为其他类型的创建都是 同 new 关键字创建出来的实例。 （前面说到 new 关键字做了什么)；</div>

Object.prototype.toString.call

Object.prototype.toString.call([])展示[object Array]

Object.prototype.toString.call(null)展示[object null]

Object.prototype.toString.call(Set 类型的变量）展示[object Set]

Object.prototype.toString.call（Map 类型的变量）展示[object Map]

typeof 的替代方案依然无法解决的问题

```js
class People {}
let people = new People();
console.log(Object.prototype.toString.call(people)); // [object Object]
```

就是无法获取一个自定义的类的实例变量或构造函数的对象变量的真正创建类型，答案是使用 instanceof 来解决。

instanceof 格式：对象变量 instanceof 类名或函数名

instanceof 的主要作用：instanceof 帮助我们准确的判断一种自定义函数或类创建的对象变量的数据类型。

instanceof 执行后返回 true 的几种条件【符合一个即可】：
（1）对象变量.proto=类名或函数名.prototype。

解释 1：如果 instanceof 关键字左边对象变量的 proto 属性指向的原型对象空间=右边类名或函数名的 prototype 对象属性指向的原型对象空间，那么返回 true。

(2)对象变量.proto.proto.…_proto_=类名或函数名.prototype。

解释 2：instanceof 左边对象变量 proto 的 1 到多个上一级 proto 指向的原型对象空间，等于右边类名或函数名的 prototype 对象属性指向的原型对象空间，那么也返回 true，按照这个查找规律，会一直找到 object.prototype 对象属性指向的原型对象空间为止。

```js
console.log(chinesePeopleone.__proto_ === ChinesePeople.prototype);
if (chinesePeopleone instanceof People) {
	console.log("chinesePeopleone3=>true");
}
console.log(chinesepeopleone.__proto_.__proto__ === People.prototype);
if (chinesePeopleone instanceof Object) {
	console.log("chinesePeopleone4==true");
}
console.log(chinesePeopleone.__proto_.__proto_.__proto_ === object.prototy);
if (chinesePeopleone instanceof String) {
	console.log("string=true");
}
```
