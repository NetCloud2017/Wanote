# TS 泛型

1.Vue3 源码充斥着大量的 TS 泛型。懂 TS 泛型是读懂 Vue3 源码不可逾越的环节。 2.前端各种技术的声明文件【d.ts 文件】TS 泛型更是随处可见【例如：小到一个 Array，ES6 的 Set，
Map，稍微复杂点的例如：Vue3 应用的声明文件，Vuex 底层的声明文件，React 组件声明文件，axios 声
明文件，这样的例子举不胜举。】 3.现在采用 TS 整合前端框架的大中项目越来越多，而 TS 泛型必然成了你必须攻克的核心技能。如果你近几
年在公司做过稍微大点的项目，你的感触会特别深刻。 4.后端 Nodejs 和 TS 整合的频次也越来越高，优秀的 Nestjs 框架就完全采用 TS 开发。
5.TS 语法是晋级高级前端工程师，拿更高薪水，面试加分不可逾越的学习环节，而泛型语法更是重重之重，
一句我能熟练解说 Vue3 源码中的 TypeScript 语法会为你的面试加分许多。

## 泛型类

- 为什么要用泛型类?

好处 1：编译期对类上调用方法或属性时的泛型类型进行安全检查(类型安全检查)，不符合泛型实际参数类型(泛型实参类型）就编译通不过，防止不符合条件的数据增加进来。

好处 2：一种泛型类型被具体化成某种数据类型后，该数据类型的变量获取属性和方法时会有自动提示，这无疑提高代码开发效率和减少出错率。

```ts
class ArrayList<T> {
	public index: number = 0;
    pulic element: Array<T>;
	constructor() {
        this.element = []
    }
    public checkIndex () {
        if(this.index < 0 ) {
            throw new Error('数组下标不能为零')
        }
    }
	public add(obj: T) {
        if(this.checkIndex())
		this.element[this.index++] = obj;
	}
	public get(index: number): object {
		return this.element[index];
	}
}
let stuone = { stuname: "wnagwu", age: 23 }
let stuTwo = { stuname: "lisi", age: 39 }
let stuThree = { stuname: "liuqi", age: 31 }
//let arrayList = new ArrayList([stuOne, stuTwo, stuThree]);
let arrayList = new ArrayList<string>();
let  arrayNumberList = new ArrayList<number>()
let  arrayObjList = new ArrayList<typeof stuOne>()
console.log(arrayList.get(0));

```

泛型一种参数化数据类型，具有以下特点的数据类型叫泛型：

特点一：定义时不明确使用时必须明确成某种具体数据类型的数据类型。

特点二：编译期间进行数据类型安全检查的数据类型。

特别注意：

    1.类型安全检查发生在编译期间
    2.泛型是参数化的数据类型，使用时明确化后的数据类型就是参数的值

```ts
c1ass 类名<泛型形参类型>泛型形参类型一般有两种表示：

    1.A-Z任何一个字母
    2.语义化的单词来表示，绝大多数情况，泛型都是采用第一种形式表示，如下：
class ArrayList<T> {
	array: Array<T>;
	add(data: T) {}
}
```

- 泛型的 any 化和泛型的默认值问题

```ts
class ArrayList<T=any> {
	array: Array<T>;
	add(data: T) {}
}
let arr = nwe ArrayList()
arr.add(2)


any 化是一种特殊的默认参数类型

class ArrayList<T={}> {
	array: Array<T>;
	add(data: T) {}
}
let objArr = new ArrayList()
```

## object 为什么不能替代类上的泛型？

原因一：编译期间 object 无法进行类型安全检查，而泛型在编译期间可以进行类型安全检查
object 接受也只能接受所有的 object 类型的变量，比如有 Customer、Student、Dog 类的实例都是对象类型，或者自己定义的对象，都可以传递给 object 类型的方法参数或属性，但如果我们只希望添加 Customer 类的对象，当添加其他类的对象必须出现编译错误，但是 object 无法做到，就只能用泛型了。

原因二:object 类型数据无法接受非 object 类型的变量，只能接受 object 类型的变量，泛型能轻松做到正因为 object 接受也只能接受所有的 object 类型的变量，那么如果有一个集合类[数组封装类]有一个 add 方法，允许每次添加指定类型的变量到 add 方法的参数，比如：我们第一轮的希望添加 10 次字符串类型的变量，第二轮的希望添加 10 次整数类型变量，第三轮的希望添加 10 次顾客类型的变量，泛型轻松做到。object 类型数据无法接受任意非 object 类型的变量，object 只能接受所有的 object 类型的变量。

原因三：object 类型数据获取属性和方法时无自动提示一种泛型类型被具体化成某种数据类型后，该数据类型的变量获取属性和方法时会有自动提示，提高代码开发效率和减少出错率，但在 object 类型的变量无法获取数据类型的属性和方法；降低了体验感和开发效率。

- Object object unknown any 之间的区别

  Object 是所有对象的基础， 包括实例化的对象。 他可以被赋值给任何对象，和其他如数字类 Number 、 正则 RegExp 、字符串 String 等的实例。

  ```js
      let  obj：Object = 123 // 正确
      let  obj1 = Object = {} // 正确
  ```

  object 就只能赋值给对象类型, 如 function 、 [] 和 {} 。

  unknown 和 any 都是其他类的顶层类型， any 可以作为其他类型的子类型， unknown 不能，any 在编译期间不会报错， unknown 会； unknown 类型的值只能是 any 和其本身。

- any 为什么不能替代类上的泛型？

原因一：编译期间 any 无法进行类型安全检查，而泛型在编译期间可以进行类型安全检查,我们学过：any 是所有类型的父类，也是所有类型的子类如果我们现在是一个宠物店类，希望只能添加 Dog 类，当调用 add 方法添加 Customer、Student 类必定出现编译错误，从而保证了类型安全检查，但是 any 类型无法保证类型安全检查,可以为任意类型，包括 string,number,boolean,null,undefined,never,void,unknown 基础数据类型和数组，类，接口类型，type 类型的变量全部能接受，不会进行无法进行类型安全检查。

原因二：any 扩大数据类型的属性后没有编译错误导致潜在错误风险，而泛型却有效的避免了此类问题发生 ,any 类型可以获取任何属性和任意方法而不会出现编译错误，因为 any 可以代表任意数据类型来获取任意属性和任意方法，但是泛型类型被具体化成某种数据类型后，该数据类型的变量调用该数据类型之外的属性和方法时，出现编译错误，这也减少了代码隐藏潜在错误的风险。

原因三：any 类型数据获取属性和方法时无自动提示，泛型有自动提示彩蛋：any 类型可以获取任何属性和任意方法而不会出现编译错误，因为 any 可以代表任意数据类型的任意属性和任意方法： 【any 的这个特性是一把双刃剑， 当我们需要这么使用， 它给我们带来方便， 但是大多数情况下我们是不需要这么做的】

## 美团分页类实现

### 理解 Dao

定义：NodeJS 或其他后端语言（例如 JAVA）中的数据访问层【就是很多类的合集，每一个类就是一个 Dao 类】简单点说：DAO 层的每一个类一般是后端数据表中一个实体的增删改查操作【方法】的封装类。完成了什么：页面上的某个功能操作需要的数据都来自某个 DAO 类的一个或者多个方法返回的结果。【先经过 Service，Service 大家先暂时不用管】。

Dao 层出现的意义：

（1）封装性+见名思义【可读性好】：当我们执行查询只需多次调用 find 相关的方法，执行删除就调用 delete 相关的方法….，一目了然。

（2)复用性：复用性表现在方法被重复多次调用，通常页面上多个功能有可能需要调用同一个 Dao 类的同一个方法，我们举一个简单例子和稍微复杂的例子【权限管理，和本门课程无关，只需知道即可】

举例 1：注册和登录我们都需要调用 UserDao 类的 findUser 方法。

举例 2：权限管理功能中为角色定制权限时【用户为角色重新分配新的权限，删除旧的权限】，和根据角色查询权限这两个功能都需要用到校色查询权限的方法[findRightByRoleld】。

（3）分工明确，各司其职，利于维护：每一个 Dao 类把混杂在其他位置中的代码分离出来，单独成类，后期修改维护都非常方便。

DAO 层中的类如何命名：

从规范上要求：DAO 层中的每一个类都命名都以 DAO 结尾，常规的操作一般一个 Dao 方法就能搞定。例如页面显示所有的美食数据来自 FoodDao 的 findAllFoods 方法，而每一个美食的详细数据来自于 FoodDao 的 findOne。

### 分页类实现

### 泛型改写分页类

### T extends object 泛型约束在分页类中的使用
