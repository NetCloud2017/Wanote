# Promise

在 Promise 没有出现之前看看我们的代码都是怎么处理异步编程的。

```js
//执行状态
function onResolve(response) {
	console.log(response);
}
function onReject(error) {
	console.log(error);
}

let xhr = new XMLHttpRequest();
xhr.ontimeout = function (e) {
	onReject(e);
};
xhr.onerror = function (e) {
	onReject(e);
};
xhr.onreadystatechange = function () {
	onResolve(xhr.response);
};

//设置请求类型，请求URL，是否同步信息
let URL = "https://time.geekbang.com";
xhr.open("Get", URL, true);

//设置参数
xhr.timeout = 3000; //设置xhr请求的超时时间
xhr.responseType = "text"; //设置响应返回的数据格式
xhr.setRequestHeader("X_TEST", "time.geekbang");

//发出请求
xhr.send();
```

在这段代码中，我们将整个请求的处理流程都暴露在同一段代码中, 而实际上我们只关注的是请求的输入和获取到的返回结果，这样使得我们的代码变得非常臃肿，不不连贯。这些异步回调影响到我们的编码方式, 所以我们将异步请求的处理过程封装起来。

```js
//makeRequest用来构造request对象
function makeRequest(request_url) {
	let request = {
		method: "Get",
		url: request_url,
		headers: "",
		body: "",
		credentials: false,
		sync: true,
		responseType: "text",
		referrer: "",
	};
	return request;
}

//[in] request，请求信息，请求头，延时值，返回类型等
//[out] resolve, 执行成功，回调该函数
//[out] reject  执行失败，回调该函数
function XFetch(request, resolve, reject) {
	let xhr = new XMLHttpRequest();
	xhr.ontimeout = function (e) {
		reject(e);
	};
	xhr.onerror = function (e) {
		reject(e);
	};
	xhr.onreadystatechange = function () {
		if ((xhr.status = 200)) resolve(xhr.response);
	};
	xhr.open(request.method, URL, request.sync);
	xhr.timeout = request.timeout;
	xhr.responseType = request.responseType;
	//补充其他请求信息
	//...
	xhr.send();
}

XFetch(
	makeRequest("https://time.geekbang.org"),
	function resolve(data) {
		console.log(data);
	},
	function reject(e) {
		console.log(e);
	}
);
```

这样我们使用 XFetch 发送请求，可以使我们的关注点放在输入和输出上不用关注请求流程中的处理流程。但是当处理一个接口依赖于另一个接口的数据这种业务时，就会有**回调地狱**问题。

```js
XFetch(makeRequest('https://time.geekbang.org/?category'),
      function resolve(response) {
          console.log(response)
          XFetch(makeRequest('https://time.geekbang.org/column'),
              function resolve(response) {
                  console.log(response)
                  XFetch(makeRequest('https://time.geekbang.org')
                      function resolve(response) {
                          console.log(response)
                      }, function reject(e) {
                          console.log(e)
                      })
              }, function reject(e) {
                  console.log(e)
              })
      }, function reject(e) {
          console.log(e)
      })
```

问题：

- 嵌套调用层级太多， 代码可读性差。

- 每个请求都有相同的同样的响应处理和错误处理，增加无用的代码量。且每次都有 resolve 和 reject 两个状态。这样嵌套调用大大增加了不确定性。

为了解决这两个问题，Promise 就诞生了， 我们看看 Promise 是怎么解决这两个问题的。

重构 XFetch 代码:

```js
function XFetch(request) {
	function executor(resolve, reject) {
		let xhr = new XMLHttpRequest();
		xhr.open("GET", request.url, true);
		xhr.ontimeout = function (e) {
			reject(e);
		};
		xhr.onerror = function (e) {
			reject(e);
		};
		xhr.onreadystatechange = function () {
			if (this.readyState === 4) {
				if (this.status === 200) {
					resolve(this.responseText, this);
				} else {
					let error = {
						code: this.status,
						response: this.response,
					};
					reject(error, this);
				}
			}
		};
		xhr.send();
	}
	return new Promise(executor);
}
```

重构请求流程

```js
// 对多个错误处理进程合并。消灭回调地狱。
var x1 = XFetch(makeRequest("https://time.geekbang.org/?category"));
var x2 = x1.then(function onResolve(value) {
	// 延时绑定的回调函数
	console.log(value);
	// 将返回值穿透到最外层。
	return XFetch(makeRequest("https://www.geekbang.org/column"));
}，function onReject(error) {
    console.log(error)
});
var x3 = x2.then((value) => {
	console.log(value);
	return XFetch(makeRequest("https://time.geekbang.org"));
});
x3.catch((error) => {
	console.log(error);
});
```

Promise 主要通过以下两步来解决回调问题的：

首先，Promise 实现了回调函数的延时绑定。回调函数的延时绑定在代码上体现就是先创建 Promise 对象 x1，通过 Promise 的构造函数 executor 来执行业务逻辑；创建好 Promise 对象 x1 之后，再使用 x1.then 来设置回调函数。

其次，需要将回调函数 onResolve 的返回值穿透到最外层。因为我们会根据 onResolve 函数的传入值来决定创建什么类型的 Promise 任务，创建好的 Promise 对象需要返回到最外层，这样就可以摆脱嵌套循环了。

至于合并错误处理则是基于 Promise 的错误具有 "冒泡"性质。会一直向后传递，直到被 onReject 函数处理或 catch 语句捕获为止。这样就不需要频繁的添加错误处理了。

## Test

打印输出结果。

```js
let x1 = Promise.reject();
let x2 = x1.then(
	() => {},
	function (err) {
		console.log(err, "err");
	}
);

x2.catch((error) => {
	console.log(error, "err2");
});
```

答案： undefined， "err"

实现模拟一个 Promise。

```js

```
