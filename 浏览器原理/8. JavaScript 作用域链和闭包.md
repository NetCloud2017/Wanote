# JavaScript 作用域链和闭包

## 作用域链

> 就是作用域之间的关系链条。

我们知道当获取一个变量的时候会去执行上下文的词法环境和变量环境中查找，当没有找到的时候， 会向外层的作用域查找，直到找到最外层的全局作用域为止。那么它是通过什么方式去向外层作用域查找的呢? 其实， 每一个执行上下文的变量环境中都有一个指向外部执行上下文的引用 **outer**。当在当前作用域中没有查找到改变量时， 就会顺着这个外部引用向外部继续查找。

**outer** 的指向是由 JavaScript 的词法作用域决定的，词法作用域是静态作用域，是由代码中函数声明的位置来决定的, 通过它就能够预测代码在执行过程中如何查找标识符，并且词法作用域和函数是怎么调用的没有任何关系。

<img src="./img/8scope2.png" />

下面我们用一段代码来说明一下作用域链：

<img src="./img/8scope.png"  />

词法作用域确定了 bar 函数的执行上下文 outer 指向全局执行上下文，foo 执行上下文的 outer 也指向 全局执行上下文。 因此不管 bar 函数在 foo 内部被调用，还是在全局环境中被调用， 最终 test 的值都会顺着作用域链找到最外部的 test 变量。

## 闭包

了解了作用域链之后我们来看看闭包。

```js
function foo() {
	var myName = "极客时间";
	let test1 = 1;
	const test2 = 2;
	var innerBar = {
		getName: function () {
			console.log(test1);
			return myName;
		},
		setName: function (newName) {
			myName = newName;
		},
	};
	return innerBar;
}
var bar = foo();
bar.setName("极客邦");
bar.getName();
console.log(bar.getName());
```

通过代码调用我们可以发下， 当我们运行 `foo` 函数之后，其中的 `myName` 和 `test1` 没有被垃圾回收， 让然可以通过 `innerBar` 的 `setName` 和 `getName` 访问到，且只能通过这两个地方访问到。

在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。

通过 chrome 调试工具查看闭包：

<img src="./img/8closure.png" />

闭包的使用原则： 从上述代码可以看出， 我们返回的对象时赋值给了一个全局变量 bar ，它会直到页面关闭时才会被回收，假如我们的闭包一直使用的，就可以这样设计代码。但是使用不频率不高的话就会使内存泄漏。因此我们可以将它赋值给一个局部变量来规避这个问题。
