1.问题一：ref 函数是如何进行实现的呢?

    ref函数本质上是生成了一个RefImpl类型的实例对象，通过get和set标记处理了
    value 函数.

2.问题二：ref 可以构建简单数据类型的响应性吗?

    是的。ref可以构建简单数据类型的响应性

3.问题三：为什么 ref 类型的数据，必须要通过.value 访问值呢?

    1.因为ref 需要处理简单数据类型的响应性，但是对于简单数据类型而言，它无法通过proxy 建立代理。

    2.所以 vue通过get value()和set value（）定义了两个属性函数，通过主动触发这两个函数（属性调用）的形式来进行依赖收集和触发依赖

    3.所以我们必须通过.value来保证晌应性。

由以上逻辑可知：

    1.const value 是 proxy 类型的实例，即：代理对象，被代理对象为`{name：‘张三'}`
    2.执行 value.name='李四'，本质上是触发了proxy的setter
    3.根据reactive 的执行逻辑可知，此时会触发trigger 触发依赖。
    4.至此，修改视图

在这样的代码，我们需要知道的最重要的一点是：ref 中， **简单数据类型，不具备数据件监听的概念，即本身并不是响应性的。**

只是因为 vue 通过了 set value() 的语法，把函数调用变成了属性调用的形式，让我们通过主动调用该函数，来完成了一个“类似于”响应性的结果。

总结：

由以上逻辑可知：

1.对于 ref 函数，会返回 RefImpl 类型的实例

2.在该实例中，会根据传入的数据类型进行分开处理

    1.复杂数据类型：转化为 reactive 返回的proxy 实例
    2.简单数据类型：不做处理

3.无论我们执行 obj.value.name 还是 obj.value.name=xxx 本质上都是触发了
get value

4.之所以会进行响应性是因为 obj.value 是一个 reactive 函数生成的 proxy
